<!DOCTYPE html>
<html>
  <head>
    <!--
      /**
       * This webpage is meant to be run from a local/remote server due to reading of JSON file.
       * It takes in the following querystring param(s):
       * @param {string} data - Path to JSON file for songbook.
       */
    -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title> <!-- to be filled in by JavaScript -->

    <style>
      html,
      body {
        background-color: lightyellow;
        font-family: Helvetica, Arial, SimHei, "黑体", sans-serif;
        font-size: 16px;
      }

      footer {
        font-style: italic;
        margin-top: 1em;
        text-align: right;
      }

      table {
        border-spacing: 0;
        border-collapse: separate;
        width: 100%;
      }
      th, td {
        border: 1px solid #ccc;
        padding: 5px;
      }
      th {
        background: #ddd;
      }
      td:not(:first-child) {
        text-align: center;
      }

      a {
        color: #0000ff;
        text-decoration: none;
      }
      a:hover {
        color: #ff00ff;
        text-decoration: underline;
      }
      a[id] {
        color: black;
        text-decoration: none;
      }
      a[id]:hover {
        color: black;
        text-decoration: none;
      }

      .songbook-title {
        margin: 0 auto;
        text-align: center;
      }

      .section-link {
        display: inline-block;
        margin: 0.5em;
      }
    </style>
  </head>

  <body>
     <!-- Empty elements to be filled in by JavaScript -->
    <h1 class="songbook-title"></h1>

    <h2>Table of Contents</h2>
    <nav class="table-of-contents"></nav>
    <main class="sections"></main>

    <footer></footer>

    <script>
      (function () {
          const COMMENTS = '//';
          const LANG_EN = 'en';
          const LANG_CN = 'cn';

          let queryParams = null;
          let data = null;

          /**
           * Initialization
           *
           * @returns {void}
           */
          function init() {
              let dataFile = getQueryParam('data', '');
              if (!dataFile) {
                  return;
              }

              readJsonFile(dataFile, function (json) {
                  // Save contents of JSON file
                  data = json;

                  // Book title and copyright
                  let bookTitles = Object.values(data['title'] || '');
                  document.title = bookTitles.join(' ');
                  document.querySelector('.songbook-title').innerHTML = bookTitles.join('<br>');
                  document.querySelector('footer').innerHTML = data['copyright'] || '';

                  // Table of contents and sections
                  let sections = data.sections || {};
                  let tableOfContentsHtml = '';
                  let sectionsHtml = '';
                  Object.entries(sections).forEach(function (entry) {
                      let sectionJsonKey = entry[0];
                      let section = entry[1];
                      let sectionResult = getSectionInfo(sectionJsonKey, section);

                      sectionResult.forEach(function (sectionInfo) {
                          tableOfContentsHtml += sectionInfo.link;

                          if (!isEmpty(sectionInfo.songs)) {
                              sectionsHtml += sectionInfo.anchor + "\n<table>\n"
                                  + '<tr><th>Name</th><th>Lyrics</th><th>Music</th>'
                                  + '<th>Key/Time Signature</th><th>Notes</th></tr>';

                              sectionInfo.songs.forEach(function (song) {
                                  sectionsHtml += sprintf(
                                      '<tr><td>%s%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>',
                                      song.songPrefix ? song.songPrefix + ': ' : '',
                                      song.name,
                                      song.lyrics,
                                      song.music,
                                      song.signature,
                                      song.notes
                                  );
                              });
                          }
                      });
                  });
                  document.querySelector('.table-of-contents').innerHTML = tableOfContentsHtml.trim();
                  document.querySelector('.sections').innerHTML = sectionsHtml.trim();
              });
          }

          /**
           * Get rendering for section info, including subsections
           *
           * Subsections, if any, will be placed at the same level of the section itself.
           *
           * If a section has no songList key set, no info is generated for the section itself, but if it
           * has subsections, info will be generated for those subsections (if they have songList key set).
           *
           * @param {string} key - JSON key for section. Used for English title if latter is not specified.
           * @param {object} section - JSON value for section.
           * @returns {object[]} 1st element will the section itself, followed by 1 element for each subsection if any.
           *     [
           *       {
           *         title: <combination of English and Chinese titles>,
           *         anchor: <HTML for section header anchor>,
           *         link: <HTML for section link as used in table of contents>,
           *         songs: [<as per return result of getSongInfo9)>]
           *       }
           *     ]
           */
          function getSectionInfo(key, section) {
              let result = [];
              let sectionInfo = {
                  title: '',
                  anchor: '',
                  link: '',
                  songs: []
              };

              // Skip comments
              if (COMMENTS === key) {
                  return result;
              }

              // Only generate info for current section and add to result if its songList key is set
              let songList = section.songList || [];
              if (!isEmpty(songList)) {
                  let sectionTitle = resolveTitle(key, section.title);
                  let sectionVarName = titleToVariableName(sectionTitle);
                  let songs = (data && data.songs) || {};

                  // Song ranges
                  let songRanges = [];
                  songList.forEach(function (songRange) {
                      // For textual representation
                      songRanges.push(
                          (2 === songRange.length) ? songRange[0] + ' - ' + songRange[1] : songRange.join(', ')
                      );

                      // Collate songs
                      if (2 === songRange.length) { // convert ["1", "3"] to ["1", "2", "3"]
                          let start = parseInt(songRange[0]);
                          let end = parseInt(songRange[1]);
                          songRange = new Array(end - start + 1).fill().map((val, index) => (index + start + ''));
                      }
                      songRange.forEach(function (songJsonKey) {
                          let song = (songs && songs[songJsonKey]) || null;
                          if (!song) {
                              return;
                          }

                          sectionInfo.songs.push(getSongInfo(songJsonKey, song));
                      });
                  });

                  sectionInfo.title = sectionTitle;
                  sectionInfo.anchor = sprintf(
                      '<h3><a id="%s">%s</a></h3>',
                      sectionVarName,
                      sectionTitle
                  );
                  sectionInfo.link = sprintf(
                      '<div class="section-link">[<a href="#%s">%s %s</a>]</div>',
                      sectionVarName,
                      sectionTitle,
                      songRanges.join(', ')
                  );

                  result.push(sectionInfo);
              }

              // Iterate thru subsections
              let subsections = section.subsections || {};
              Object.entries(subsections).forEach(function (entry) {
                  let subsectionJsonKey = entry[0];
                  let subsection = entry[1];
                  let subsectionResult = getSectionInfo(subsectionJsonKey, subsection);

                  if (!isEmpty(subsectionResult)) {
                      result = result.concat(subsectionResult);
                  }
              });

              return result;
          }

          /**
           * Get rendering for song info
           *
           * @param {string} key - JSON key for song. Used for English title if latter is not specified.
           * @param {object} song - JSON value for song.
           * @returns {object}
           *     {
           *       songPrefix: <bookPrefix + song number>
           *       name: <HTML for Name column>
           *       lyrics: <HTML for Lyrics column>
           *       music: <HTML for Music column>
           *       signature: <HTML for Key/Time Signature column>
           *       notes: <HTML for Notes column>
           *     }
           */
          function getSongInfo(key, song) {
              let bookPrefix = data.bookPrefix || '';
              let songPrefix = (null === key.match(/^\d+$/)) ? '' : (bookPrefix + key.padStart(3, '0'));
              let lyrics = song.lyrics || {};
              let music = song.music || {};
              let tune = music.tune || '';
              let notes = song.notes || [];

              return {
                  songPrefix: songPrefix,
                  name: resolveTitle(key, song.title),
                  lyrics: (lyrics.authors || []).join(', '),
                  music: (tune ? tune.toUpperCase() + '<br>' : '') + (music.composers || []).join(', '),
                  signature: (music.keySignature || []).join(', ') + '<br>' + (music.timeSignature || []).join(', '),
                  notes: notes.join('<br>')
              };
          }

          /**
           * Resolve title for section/song, combining all language versions
           *
           * @param {string} jsonKey - JSON key for section/song. This is used for the English title if latter not set.
           * @param {object} titles - Value for "titles" key in section/song, e.g. { "en":"A", "cn":"甲" }.
           * @returns {string}
           */
          function resolveTitle(jsonKey, titles) {
              titles = titles || {};

              let titleEn = titles[LANG_EN] || jsonKey || '';
              let titleCn = titles[LANG_CN] || '';

              return titleEn + (titleCn ? ' ' + titleCn : '');
          }

          /**
           * Convert title to variable name
           *
           * @param {string} title
           * @returns {string}
           */
          function titleToVariableName(title) {
              return (title || '').toLowerCase().replace(/[^a-z0-9_\-\s]/gi, '').trim().replace(/\s/g, '-');
          }

          /**
           * Simple string replacement function
           *
           * @example sprintf('<img src="%s" class="%s" />', 'a.png', 'beta') => <img src="a.png" class="beta" />
           * @link https://github.com/zionsg/javascript/blob/master/sprintf/sprintf.js
           * @param {string} format - Use "%s" as placeholder.
           * @param {...string} arguments - Add as many arguments as there are %s after the format.
           * @returns {string}
           */
          function sprintf(format) {
              format = format || '';

              for (var i = 1; i < arguments.length; i++) {
                  format = format.replace(/%s/, arguments[i]);
              }

              return format;
          }


          /**
           * Check if value is empty
           *
           * @param {mixed} value
           * @returns {boolean}
           */
          function isEmpty(value) {
              // (null == value) checks for both (null === value) and (undefined === value)
              // ('null' === x) is to cater for null in JSON cast to "null"
              if (!value || null == value || 'null' === value) {
                  return true;
              }

              // [] is not considered empty, hence must check length
              if (value instanceof Array) {
                  return (0 === value.length);
              }
          }

          /**
           * Read JSON file
           *
           * @param {string} file - Path to JSON file.
           * @param (function(string): void) callback - Callback to receive contents of JSON file.
           * @returns {void}
           */
          function readJsonFile(file, callback) {
              let req = new XMLHttpRequest();
              req.overrideMimeType('application/json');
              req.open('GET', file, true);
              req.onreadystatechange = function () {
                  if (XMLHttpRequest.DONE === req.readyState && 200 === req.status) {
                      let json = null;
                      try {
                          json = JSON.parse(req.responseText);
                      } catch (e) {
                          json = null;
                      }

                      callback(json);
                  }
              }

              req.send(null);
          }

          /*
           * Get value of query string param
           *
           * @param {string} paramName - Name of querystring param.
           * @param {*} defaultValue - Value to use if param is not found.
           * @returns {*} An array will be returned if the param has multiple values, e.g. "?a=1&a=2" returns [1, 2].
           */
          function getQueryParam(paramName, defaultValue) {
              if (null === queryParams) { // parse just once
                  queryParams = {};
                  window.location.search.substr(1).split('&').forEach(function (item) {
                      let pair = item.split('=');
                      let key = pair[0];
                      let value = pair[1] && decodeURIComponent(pair[1]); // null-coalescing/short-circuit

                      // ignore empty params
                      if (value !== '') {
                          (queryParams[key] = queryParams[key] || []).push(value); // null-coalescing/short-circuit
                      }
                  });
              }

              let result = queryParams[paramName];
              if (undefined === result) {
                  return defaultValue;
              }

              // All the values are stored as arrays. If array only has 1 value, return that.
              return (1 === result.length) ? result[0] : result;
          }

          // Run init
          init();
      })();
    </script>
  </body>
</html>
